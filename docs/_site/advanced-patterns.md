# Advanced Patterns: AdaptiveTest Class

> **For power users, tooling authors, and polyglot teams**

While the simple `discover()` function handles 90% of use cases, the `AdaptiveTest` class provides a structured, declarative pattern for advanced scenarios. This page explains when and why to use the class-based approach.

## When to Use AdaptiveTest Class

### 1. Automated Scaffolding & Tooling

The CLI uses this pattern for generated tests because it provides a clear structure that tools can analyze and modify:

```javascript
// Generated by: npx adaptive-tests scaffold src/UserService.js
class UserServiceAdaptiveTest extends AdaptiveTest {
  getTargetSignature() {
    return {
      name: 'UserService',
      type: 'class',
      methods: ['createUser', 'updateUser', 'deleteUser']
    };
  }

  async runTests(Target) {
    describe('UserService', () => {
      test('should create users', async () => {
        const service = new Target();
        const user = await service.createUser({ name: 'Alice' });
        expect(user.id).toBeDefined();
      });
    });
  }
}

new UserServiceAdaptiveTest();
```

**Benefits for tooling:**

- **Introspectable signatures** - Tools can read `getTargetSignature()` to understand test intent
- **Consistent structure** - All generated tests follow the same pattern
- **Easy modification** - Tools can update signatures and tests programmatically

### 2. Cross-Language Consistency

Teams using multiple adaptive-tests packages benefit from consistent patterns:

**JavaScript:**

```javascript
class PaymentServiceAdaptiveTest extends AdaptiveTest {
  getTargetSignature() {
    return { name: 'PaymentService', type: 'class' };
  }
  async runTests(Target) { /* tests */ }
}
```

**Python:**

```python
class PaymentServiceAdaptiveTest(AdaptiveTest):
    def get_target_signature(self):
        return {"name": "PaymentService", "type": "class"}

    def run_tests(self, target):
        # tests
```

**Java:**

```java
@AdaptiveTest(name = "PaymentService", type = "class")
public class PaymentServiceAdaptiveTest {
    // tests
}
```

### 3. Complex Lifecycle Hooks

When tests need sophisticated setup/teardown logic that benefits from inheritance:

```javascript
class DatabaseAdaptiveTest extends AdaptiveTest {
  async beforeDiscovery() {
    this.testDb = await createTestDatabase();
    this.cleanup = [];
  }

  async afterDiscovery(Target) {
    // Configure discovered target with test database
    Target.configure({ database: this.testDb });
  }

  async afterTests() {
    await Promise.all(this.cleanup.map(fn => fn()));
    await this.testDb.close();
  }

  getTargetSignature() {
    return { name: 'UserRepository', type: 'class' };
  }

  async runTests(Target) {
    describe('UserRepository', () => {
      beforeEach(() => {
        this.cleanup.push(() => this.testDb.truncate('users'));
      });

      test('should persist users', async () => {
        const repo = new Target();
        const user = await repo.create({ name: 'Bob' });
        expect(await repo.findById(user.id)).toEqual(user);
      });
    });
  }
}
```

### 4. Shared Test Infrastructure

When multiple test classes need common functionality:

```javascript
class ApiTestBase extends AdaptiveTest {
  async beforeDiscovery() {
    this.server = await startTestServer();
    this.client = createApiClient(this.server.url);
  }

  async afterTests() {
    await this.server.close();
  }

  // Common assertions
  assertValidResponse(response) {
    expect(response.status).toBe(200);
    expect(response.data).toBeDefined();
  }
}

class UserApiAdaptiveTest extends ApiTestBase {
  getTargetSignature() {
    return { name: 'UserController', type: 'class' };
  }

  async runTests(Target) {
    describe('User API', () => {
      test('should create users', async () => {
        const controller = new Target();
        const response = await this.client.post('/users', { name: 'Charlie' });
        this.assertValidResponse(response);
      });
    });
  }
}
```

## Advanced Configuration

### Custom Discovery Options

```javascript
class OptimizedServiceTest extends AdaptiveTest {
  getDiscoveryOptions() {
    return {
      maxDepth: 5,              // Limit search depth
      skipDirectories: ['vendor', 'legacy'],
      extensions: ['.ts', '.js'],
      scoring: {
        paths: {
          positive: { '/services/': 20 },
          negative: { '/deprecated/': -50 }
        }
      }
    };
  }

  getTargetSignature() {
    return { name: 'OptimizedService', type: 'class' };
  }
}
```

### Dynamic Signatures

```javascript
class FlexibleAdaptiveTest extends AdaptiveTest {
  getTargetSignature() {
    // Signature can be computed dynamically
    const targetName = process.env.TEST_TARGET || 'DefaultService';
    return {
      name: targetName,
      type: 'class',
      methods: this.getExpectedMethods(targetName)
    };
  }

  getExpectedMethods(targetName) {
    const methodMap = {
      'UserService': ['create', 'update', 'delete'],
      'PaymentService': ['charge', 'refund', 'verify'],
      'DefaultService': ['process']
    };
    return methodMap[targetName] || [];
  }
}
```

## Migration from Simple API

If you start with the simple API and need advanced features:

**Before (Simple):**

```javascript
const UserService = await discover('UserService');
describe('UserService', () => {
  test('should work', () => {
    const service = new UserService();
    expect(service).toBeDefined();
  });
});
```

**After (Advanced):**

```javascript
class UserServiceAdaptiveTest extends AdaptiveTest {
  getTargetSignature() {
    return { name: 'UserService', type: 'class' };
  }

  async runTests(Target) {
    describe('UserService', () => {
      test('should work', () => {
        const service = new Target();
        expect(service).toBeDefined();
      });
    });
  }
}

new UserServiceAdaptiveTest();
```

## Best Practices

### 1. Use Inheritance Wisely

- Create base classes for common patterns
- Don't over-engineer simple tests
- Prefer composition when inheritance gets complex

### 2. Keep Signatures Specific

```javascript
// Good - Specific and actionable
getTargetSignature() {
  return {
    name: 'EmailService',
    type: 'class',
    methods: ['send', 'template', 'queue'],
    properties: ['config', 'transport']
  };
}

// Avoid - Too generic
getTargetSignature() {
  return { name: 'Service', type: 'class' };
}
```

### 3. Document Your Patterns

```javascript
/**
 * Base class for API endpoint tests
 * Provides: test server, auth client, common assertions
 * Usage: Extend this class and implement getTargetSignature() + runTests()
 */
class ApiTestBase extends AdaptiveTest {
  // implementation
}
```

## When NOT to Use AdaptiveTest Class

### Stick with Simple API When

- **Quick tests** - Single test file with straightforward requirements
- **Learning** - New to adaptive-tests, prefer simple patterns first
- **One-off tests** - No reuse or tooling needed
- **Prototyping** - Exploring ideas, need minimal ceremony

```javascript
// Perfect for simple cases
const Calculator = await discover('Calculator');
test('should add numbers', () => {
  expect(new Calculator().add(2, 3)).toBe(5);
});
```

## Tooling Integration

### CLI Generation

```bash
# Generates AdaptiveTest class
npx adaptive-tests scaffold src/UserService.js

# Converts simple tests to class-based
npx adaptive-tests convert tests/ --explicit
```

### IDE Support

VS Code extension recognizes `AdaptiveTest` classes and provides:

- Signature validation
- Quick navigation to discovered targets
- Test generation assistance

## Summary

The `AdaptiveTest` class is powerful but not always necessary. Use it when you need:

- **Structured patterns** for tooling and generation
- **Cross-language consistency** in polyglot teams
- **Complex lifecycle hooks** for setup/teardown
- **Shared infrastructure** across multiple test files

For everything else, the simple `discover()` function is usually the better choice.

**Progressive Learning Path:**

1. **Start with invisible mode** - Zero learning curve
2. **Graduate to `discover()`** - Simple, direct control
3. **Adopt `AdaptiveTest` class** - When you need advanced features

Each layer builds on the previous, giving you exactly the power you need without unnecessary complexity.
