#!/usr/bin/env node

/**
 * Build helper for first-party packages that live inside this monorepo but are
 * published independently (Vite / Webpack plugins, etc.).
 *
 * The script purposely avoids external build tooling so it can run in
 * sandboxed environments or CI without needing to download bundlers.
 */

const fs = require('fs');
const path = require('path');
const ts = require('typescript');

const repoRoot = path.resolve(__dirname, '..');

const packages = [
  {
    name: 'vite-plugin-adaptive',
    root: path.join(repoRoot, 'packages', 'vite-plugin-adaptive'),
    entrypoints: [
      {
        input: 'src/index.ts',
        builds: [
          {
            module: ts.ModuleKind.CommonJS,
            outFile: 'dist/index.js',
            banner: '/** Generated by scripts/build-packages.js (CommonJS) */\n',
          },
          {
            module: ts.ModuleKind.ESNext,
            outFile: 'dist/index.mjs',
            banner: '/** Generated by scripts/build-packages.js (ESM) */\n',
          },
        ],
      },
    ],
    declarationEntrypoints: ['src/index.ts'],
  },
  {
    name: 'webpack-plugin-adaptive',
    root: path.join(repoRoot, 'packages', 'webpack-plugin-adaptive'),
    entrypoints: [
      {
        input: 'src/index.ts',
        builds: [
          {
            module: ts.ModuleKind.CommonJS,
            outFile: 'dist/index.js',
            banner: '/** Generated by scripts/build-packages.js (CommonJS) */\n',
          },
        ],
      },
      {
        input: 'src/loader.ts',
        builds: [
          {
            module: ts.ModuleKind.CommonJS,
            outFile: 'dist/loader.js',
            banner: '/** Generated by scripts/build-packages.js (CommonJS) */\n',
          },
        ],
      },
    ],
    declarationEntrypoints: ['src/index.ts', 'src/loader.ts'],
  },
];

const argScopes = process.argv
  .slice(2)
  .filter((arg) => arg.startsWith('--scope='))
  .map((arg) => arg.split('=')[1])
  .filter(Boolean);

const selectedPackages = argScopes.length
  ? packages.filter((pkg) => argScopes.includes(pkg.name))
  : packages;

if (selectedPackages.length === 0) {
  console.error('[build-packages] No matching packages for scopes:', argScopes.join(', '));
  process.exitCode = 1;
  return;
}

function ensureDir(dirPath) {
  fs.mkdirSync(dirPath, { recursive: true });
}

function cleanDist(packageRoot) {
  const distPath = path.join(packageRoot, 'dist');
  fs.rmSync(distPath, { recursive: true, force: true });
  fs.mkdirSync(distPath, { recursive: true });
}

function transpileFile({ packageRoot, input, build }) {
  const sourcePath = path.join(packageRoot, input);
  const outputPath = path.join(packageRoot, build.outFile);
  const source = fs.readFileSync(sourcePath, 'utf8');

  const compilerOptions = {
    module: build.module,
    target: ts.ScriptTarget.ES2019,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    esModuleInterop: true,
    allowSyntheticDefaultImports: true,
    resolveJsonModule: true,
    noResolve: true,
    sourceMap: false,
    inlineSources: false,
  };

  const transpileResult = ts.transpileModule(source, {
    compilerOptions,
    fileName: sourcePath,
    reportDiagnostics: false,
  });

  ensureDir(path.dirname(outputPath));
  const banner = build.banner ?? '';
  fs.writeFileSync(outputPath, `${banner}${transpileResult.outputText}`);
}

function emitDeclarations(pkg) {
  const outDir = path.join(pkg.root, 'dist');
  const rootDir = path.join(pkg.root, 'src');
  const entryFiles = pkg.declarationEntrypoints.map((entry) => path.join(pkg.root, entry));

  const program = ts.createProgram(entryFiles, {
    declaration: true,
    emitDeclarationOnly: true,
    outDir,
    rootDir,
    target: ts.ScriptTarget.ES2019,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    esModuleInterop: true,
    allowSyntheticDefaultImports: true,
    resolveJsonModule: true,
    noResolve: true,
    skipLibCheck: true,
    noEmitOnError: false,
  });

  program.emit();
}

for (const pkg of selectedPackages) {
  console.log(`[build-packages] Building ${pkg.name}...`);
  cleanDist(pkg.root);

  for (const entry of pkg.entrypoints) {
    for (const build of entry.builds) {
      transpileFile({ packageRoot: pkg.root, input: entry.input, build });
    }
  }

  emitDeclarations(pkg);
  console.log(`[build-packages] âœ“ ${pkg.name} build artifacts written to dist/`);
}
